# Models

Object와 database schema를 동시에 정의하는 class.
* 각 모델은 `django.db.models.Model`을 상속하는 class.
* Table의 각 column이자 model의 각 field는 class attribute로 정의.
* `apps.py`의 `default_auto_field`가 default PK field를 알아서 설정해준다.

예를 들면:

```py
from django.db import models


class Musician(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    instrument = models.CharField(max_length=100)


class Album(models.Model):
    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    release_date = models.DateField()
    num_stars = models.IntegerField()
```

## Fields

Model 클래스의 attribute로 field를 정의할 때 `models.Field` object로 정의한다.

## Data Type

`Field`를 상속하는 `CharField`, `BigIntegerField` 등으로 data type을 나타낸다.
예를 들면,
* `CharField`: `VARCHAR`
* `BigIntegerField`: `BIGINT`
* `BooleanField`: `BOOL`
* `AutoField`: `IntegerField`인데 `GENERATED BY DEFAULT AS IDENTITY` (autogenerate)

한편, `PositiveIntegerField` 등 column constraint가 달린 data type들도 제공한다.

## Column Constraints

`UNIQUE`, `NOT NULL` 등의 column constraint는 `Field`에 parameter로 줄 수 있다.
* `null`: `NULL` 가능 여부 (True: `NULL` / False: `NOT NULL`)
    * `blank`: char 등이 blank value("") 가능 여부
* `unique`: `UNIQUE`
* `max_length`: `VARCHAR` 등의 length
* `db_default`: `DEFAULT`
    * `default`: django object attribute의 default value
* `choice`: 가능한 value들의 list이며 model validation에 사용
    * `{"value": "display", ...}` 이거나 `[("value", "display"), ...]`, 혹은 `Choices` 클래스
    * value는 DB에 저장되는 value, display는 유저에게 display되는 value

### Choices Class

`Choices`는 `enum.Enum` Class를 상속하고 metaclass가 `ChoicesType`이다.
`Choices`를 상속해서 enum을 정의하면 validation에서 쓸 수 있게 된다.
`TextChoices`, `IntChoices`는 `StrEnum`, `IntEnum`같은 느낌.

사용법은 [공식 reference](https://docs.djangoproject.com/en/5.0/ref/models/fields/#enumeration-types)를 참고하자.

## Table Constraints

Table constraint는 table metadata를 설정하는 `Meta`라는 nested class에 `constraints`라는 class attribute로 들어간다.
Constraint들은 `UniqueConstraint(fields=[])`, `CheckConstraint(check=Q)`가 있는데,
Check constraint의 check는 Query에서 사용하는 `Q` object가 들어간다.

## Relationships

Schema에서는 Relationship은 Foreign key로 나타나지만,
Model에서는 이를 many-to-one, one-to-one, many-to-many로 구분짓는다.
또한 대부분의 ORM이 그렇듯이 relationship access는 기본적으로 lazy하다.

N-to-1일 경우 descriptor이고, N-to-many일 경우 `Manager`이다.
Descriptor는 최초 lookup시 query를 호출하여 내부의 `_state` attribute의 `fields_cache` attribute에 캐싱한다.
`Manager`는 Django model에 대한 DB query operation interface를 제공한다.

### Reverse Accessor

Relationship은 보통 한 쪽(referencing) model에만 attribute를 만들기 때문에,
반대쪽(referenced) model에서 역으로 접근할 방법이 필요하다.
Relationship attribute는 반대쪽 model에 reverse accessor라는 attribute를 추가한다.
정확히는 Model의 class attribute에 관련된 정보를 추가하여 반대쪽 model에서 attribute lookup이 가능하게 하는 듯 하다.
Reverse accessor의 attribute 이름은 N-to-1이면 `referencing-model`, N-to-many이면 `referencing-model_set`이다.

Reverse accessor도 relationship처럼 N-to-1이면 descriptor, N-to-many이면 `Manager`이다.

### Many-to-One

`ForeignKey(Another)` 로 다른 model을 referencing하는 foreign key 필드를 만들 수 있다.
이 때 attribute 이름은 보통 `another`로 하고, DB schema에는 `another_id`라는 referencing column이 생긴다.
DB에서의 reference column에 대한 option도 `ForeignKey`에 parameter로 줘야 한다.
* `on_delete`: `ON DELETE` clause => `models.CASCADE`, `models.SET_NULL`, `models.SET_DEFAULT` 등
* `to_field`: Referenced model의 어떤 unique field를 reference할 것인지 => Default는 PK
* `related_name`: 반대쪽 model의 reverse accessor의 이름. '+'로 설정하면 reverse accessor를 만들지 않는다.

`ForeignKey`는 many-to-one 관계이므로 reverse accessor는 one-to-many 관계를 나타내는 manager이다.

Python 언어 특성상 아직 정의되지 않은 model을 사용할 수 없는데 이 때는 string으로 넘겨주면 된다.

### One-to-One

`OneToOneField` 클래스는 `ForeignKey` 클래스를 상속하며, unique constraint가 추가된 개념이다.
One-to-one 관계이므로 reverse accessor 또한 one-to-one 관계를 나타내는 descriptor(manager가 아닌)이다.

### Many-to-Many

Many-to-many relationship은 DB에서는 table로 구현한다.
따라서 many-to-many relationship의 가장 간단한 구현 방법은 intermediary model을 직접 구현하고 양 쪽 model에 대한 foreign key를 가지는 구조이다.
그러나 이 경우 한 쪽 model에서 반대쪽 model로 access하기 위해 intermediary model을 거쳐야 해 attribute access가 두 번 필요하며, 내부적으로도 쿼리가 두 번 발생한다.
이 때 `ManyToManyField` 클래스를 사용하면 편하다.
`ManyToManyField`는 intermediary model을 거치지 않고 곧바로 related model에 access하는 manager이다.
또한, many-to-many이기에 attribute 이름을 보통 복수형을 사용한다.

`ForeignKey`는 DB에서 foreign key constraint를 만들지만,
`ManyToManyField`는 `appname_model1_model2`라는 이름의 relationship table을 만든다.
따라서 `ManyToManyField`는 한 쪽 model에만 만들어야 하며, 어디에 만들든 상관이 없다. 차이점은 relationship table 이름정도?
`ForeignKey`와 마찬가지로 `ManyToManyField`도 `related_name`으로 reverse accessor 이름을 설정할 수 있다.
`ManyToManyField`의 reverse accessor 또한 many-to-may 관계를 나타내는 manager이다.

한편, intermediary model을 직접 구현하는 경우에도 `ManyToManyField`를 이용할 수 있다.
이 때는 `ManyToManyField`의 `through` parameter로 해당 model을 넘겨주면 된다.
이 경우 `ManyToManyField`가 relationship table을 만드는 것을 방지할 수 있다.

```py
class Student(models.Model):
    name = models.CharField(max_length=63)
    instructors = models.ManyToManyField("Instructor", through="Session", related_name='students')

class Instructor(models.Model):
    name = models.CharField(max_length=63)

class Session(models.Model):
    name = models.CharField(max_length=63)
    instructor = models.ForeignKey(Instructor, on_delete=models.CASCADE, related_name='sessions')
    student = models.ForeignKey(Student, on_delete=models.CASCADE, related_name='sessions')
```

이 방식이 복잡해질 때는 intermediary table에서 한 쪽 model로 향하는 foreign key가 두 개 이상인 경우이다.
이는 many-to-many relationship에 관련 없는 foreign key가 있거나,
many-to-many관계의 model이 동일한 model, 즉 자기 자신으로의 관계인 경우이다.

이런 상황에서는 `ManyToManyField`에 `through_fields`로 intermediary model의 어떤 foreign key 두 개가 many-to-many relationship을 이루는지 명시해줘야 한다.
이 값은 2-tuple이며 첫 번째 value가 `ManyToManyField`가 있는 model쪽 foreign key이다.

아래 예시는 한 명의 강사와 학생이 참여하는 일대일 학습 `Session`에 TA가 한 명씩 배정되어 있는 경우를 모델링했는데, TA 또한 학생인 경우이다.

```py
class Student(models.Model):
    name = models.CharField(max_length=63)
    instructors = models.ManyToManyField("Instructor", through="Session", related_name='students', through_fields=('student', 'instructor'))

class Instructor(models.Model):
    name = models.CharField(max_length=63)

class Session(models.Model):
    name = models.CharField(max_length=63)
    instructor = models.ForeignKey(Instructor, on_delete=models.CASCADE, related_name='sessions')
    student = models.ForeignKey(Student, on_delete=models.CASCADE, related_name='sessions')
    ta = models.ForeignKey(Student, on_delete=models.CASCADE, related_name='ta_sessions')
```

만약 `through_fields`가 누락되면 다음과 같은 에러가 발생한다.

```txt
SystemCheckError: System check identified some issues:

ERRORS:
myapp.Student.instructors: (fields.E334) The model is used as an intermediate model by 'myapp.Student.instructors', but it has more than one foreign key from 'Student', which is ambiguous. You must specify which foreign key Django should use via the through_fields keyword argument.
        HINT: If you want to create a recursive relationship, use ManyToManyField("self", through="Session").
```

한편, 자기 자신으로의 many-to-many 관계를 가지는 경우 다른 종류의 문제를 마주한다.

```py
class Player(models.Model):
    name = models.CharField(max_length=63)
    opponents = models.ManyToManyField("Player", through="Game")

class Game(models.Model):
    blue = models.ForeignKey(Player, on_delete=models.CASCADE)
    red = models.ForeignKey(Player, on_delete=models.CASCADE)
```

1. Foreign key `blue`와 `red`의 reverse accessor 이름이 둘 다 `game_set`으로 같다.
2. `ManyToManyField`인 `opponents`는 player가 blue인 game의 red player들만을 포함시킨다.

1을 해결하기 위해서는 `related_name`을 설정해줘야 하고, 2는 만약 반대로 향하고 싶다면 `through_fields`를 `('red' ,'blue')`로 설정하면 된다.

따라서 다음과 같이 고칠 수 있다.

```py
class Player(models.Model):
    name = models.CharField(max_length=63)
    blue_opponents = models.ManyToManyField("Player", through="Game", related_name='red_opponents')

class Game(models.Model):
    blue = models.ForeignKey(Player, on_delete=models.CASCADE, related_name='blue_games')
    red = models.ForeignKey(Player, on_delete=models.CASCADE, related_name='red_games')
```

## Generalization

Generalization은 `is-a` 관계를 나타낸다.
이는 OOP의 상속과 일치하는 접근이며, 따라서 model간 상속으로 쉽게 표현할 수 있다.

예를 들어, `Person` model을 상속하는 `Student`, `Instructor` model을 만든다면,
두 model은 `Person` model을 참조하는 table을 생성한다.
